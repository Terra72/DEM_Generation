/*
DEM_Generation/main.cpp
Author: Daniel Bowden BWDDAN001

DEm_Generation is the driver class to call landGen to create landscapes, treeGen to specify tree positions
and the functionality to draw trees onto a generated landscape using tree positions.

Additionally, contains the functionality to detect contour lines in the image and the relevant preprocessing
required to edit and display raster data.

Extra features include cropping of .tif maps and specifying tree orchard area manually for experimentation

*/

#include <cmath>
#include <iostream>
#include <stdexcept>
#include <vector>

#include "opencv2/core.hpp"
#include "opencv2/highgui.hpp"
#include "opencv2/imgproc.hpp"
#include "opencv2/imgcodecs.hpp"

#include "treeGen.h"
#include "landGen.h"

using namespace cv;
using namespace std;
using namespace treeGen;

struct POS{
	int x;
	int y;
}; 

Mat src_gray;
int thresh = 1;
RNG rng(12345);

Mat image;
int cornerCnt;
POS farmCorners[4]; 
int spawnX = 0;
int spawnY = 0;
int farmWidthY = 500;
int farmWidthX = 500;
int treeWidth = 30; 
int treeHeight = 15; 
int treeType = 4; // 2 or 4 for width = 30, 3 or 5 for width = 15

//different gap settings per generation type
int treeGapY;
int treeGapX; 


vector<vector<Point>> getContours(int thresh);
void thresh_callback(int, void* );
void mouse_callback(int  event, int  x, int  y, int  flag, void *param);
int** createGroveSpace();
void addTreesToImage(TreeGroup trees, bool contourDraw);
Mat copyMat(Mat & inputMat, int widthX, int widthY);
void croptTif(Mat inputImage, int newWidth, POS startPos);
void printTreeMask(TreeGroup trees, bool contourDraw);

/*
main function calling the functionality for landscape generation and tree generation
takes user choices as inputs and creates landscape
outputs final DEMs for evaluation and image processing
*/
int main (int argc, char** argv){
	//use specified map generation and display choices 
	char overlapCheck;
	char normCheck;
	char convertCheck;
	char contourCheck;
	int landscapeChoice = 1;
	cout << "Specify landscape [1...10]: " << endl;
	cin >> landscapeChoice;
	cout << "Specify tree type number [2...5]: " << endl;
	cin >> treeType;
	cout << "Overlap trees? [y/n]: " << endl;
	cin >> overlapCheck;
	cout << "Normalize image? [y/n] " << endl;
	cin >> normCheck;
	cout << "Convert to 8bit? [y/n] " << endl;
	cin >> convertCheck;
	cout << "Draw trees based on contour lines? [y/n] " << endl;
	cin >> contourCheck;

	
	if(contourCheck == 'y'){
		if(treeType == 3 || treeType == 5){
			treeWidth = 15;
		}	
		treeGapY = treeWidth + treeWidth / 6;
		treeGapX = treeWidth - treeWidth / 6; 
		if(overlapCheck == 'y'){
			treeGapX = treeWidth - treeWidth / 2;
		}
		else{
			treeGapX = treeWidth + treeWidth / 4 ;
		}
	}
	else{
		if(treeType == 3 || treeType == 5){
			treeWidth = 15;
		}	
		treeGapY = treeWidth + treeWidth / 6;
		treeGapX = treeWidth - treeWidth / 6 ; 
		if(overlapCheck != 'y'){
			cout << "asd" << endl;
			treeGapY = treeWidth + treeWidth / 4; 
			treeGapX = treeWidth + treeWidth / 4;
		}
	}
	cout << treeGapY << endl;
	cout << treeGapX << endl;
	//draw specifed landscape image based on landscapeChoice
	landGen::landscape l;
	l.drawLand(landscapeChoice); 

	Mat norming;	
	TreeGroup trees;
	vector<vector<Point>> contourLines;
	srand (time(NULL)); 
	//read in landscape DEM that has just been generated by landGen
	image = imread("output/landscape.tif", IMREAD_LOAD_GDAL |IMREAD_UNCHANGED); 
	if(!image.data){
		cout << "Failed to load image" << endl;
		return -1;
	}
	//Addtional cropping feature used for USGS DEMs:
   	//croptTif(image, 500, POS{300,500});

	//normalize image scale to 0-255, not needed for generated landscapes
	if(normCheck == 'y'){
		normalize(image, norming,0,255, cv::NORM_MINMAX);
		image = norming.clone();
	}	

	Mat out_mat1;
	if(convertCheck  == 'y'){ //convert to 8bit lessens precision of data
		image.convertTo(out_mat1, CV_8UC1);
	}
	else{
		out_mat1 = image.clone();
	}

	if(contourCheck == 'y'){
	//preprocessing of grey image to find neat contours
		//gaussian blur the source image to find contours easier
		blur( image, src_gray, Size(3,3) );
		Mat temp = src_gray*5;
		//normalize for cleaner contours/less contours
		normalize(temp, src_gray,0,5, cv::NORM_MINMAX); 
		//display contours for the image
		namedWindow( "Source" , WINDOW_NORMAL);
		resizeWindow("Source", 300,300);
		imshow( "Source", out_mat1 );
		const int max_thresh = 20;
		createTrackbar( "Canny thresh:", "Source", &thresh, max_thresh, thresh_callback );   
		thresh_callback( 0, 0 );
		waitKey();

		//store contour line end points for the image 
		contourLines = getContours(1);
	}

	//display the generated landscape.tif image
	namedWindow("display",WINDOW_NORMAL);	
	resizeWindow("display", 800,800);
	setMouseCallback("display", mouse_callback);
	imshow("display", out_mat1);
	waitKey(0);	

	//default corner values set to generate DEM's with the same orchard boundaries each time
	farmCorners[0] = {125,125};
	farmCorners[1] = {125,375};
	farmCorners[2] = {375,375};
	farmCorners[3] = {375,125};
	
	if(contourCheck != 'y'){
		//create farm area to assign available spaces where trees should be grown
		int** farmArea = createGroveSpace();
		trees.setAvailable(farmArea,farmWidthY, farmWidthX);
		//generated tree positions using treeGen
		trees.createTreesGrid(treeWidth,treeGapX,treeGapY,farmWidthY,farmWidthX);
		//draw trees based on tree positions
		addTreesToImage(trees,0); 
		//draw additional mask used for evaluation later
		printTreeMask(trees,0);
	}
	else{
		//generated tree positions using treeGen
		trees.createTreesContour(treeWidth,treeGapX,image.cols,image.rows, contourLines);
		//draw trees based on tree positions
		addTreesToImage(trees,1);
		//draw additional mask used for evaluation later
		printTreeMask(trees,1);
	}	
	//output number of trees generated
	cout << "Trees: " << trees.treeCnt << endl;
	//write final DEM to output
	imwrite("output/final.tif",image); 

	Mat out_mat2;
	if(convertCheck  == 'y'){
		image.convertTo(out_mat2, CV_8UC1);
	}
	else{
		out_mat2 = image.clone();
	}
	//display the generated final.tif image
    namedWindow("display",WINDOW_NORMAL);
    resizeWindow("display", 800,800);
	imshow("display", out_mat2);
	waitKey(0);
	return 0;
}

/*
getContours return function returing a vector<vector<Point>> data structure containing the positions for the start 
and end points of each contour line in the image, uses the openCV finction 'findContours'
*/
vector<vector<Point>> getContours(int thresh){
 	Mat tempGray;
	src_gray.convertTo(tempGray, CV_8U);
    Mat canny_output;
    Canny( tempGray, canny_output, thresh, thresh*2 );
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;
    findContours( canny_output, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE );
	return contours;
}

/*
thresh_callback void function 
displays contour line viewing window, with adjustable slider to test out different thresholds to run the "Canny" function with
*/

void thresh_callback(int, void* ){
	Mat tempGray;
	src_gray.convertTo(tempGray, CV_8U);
    Mat canny_output;
    Canny( tempGray, canny_output, thresh, thresh*2 );
    vector<vector<Point> > contours;
    vector<Vec4i> hierarchy;
    findContours( canny_output, contours, hierarchy, RETR_TREE, CHAIN_APPROX_SIMPLE );
    Mat drawing = Mat::zeros( canny_output.size(), CV_8UC3 );
    for( size_t i = 0; i< contours.size(); i++ )
    {
        Scalar color = Scalar( rng.uniform(0, 256), rng.uniform(0,256), rng.uniform(0,256) );
        drawContours( drawing, contours, (int)i, color, 2, LINE_8, hierarchy, 0 ); //(int)i
    }
	//display preview of found contours
	namedWindow("Contours",WINDOW_NORMAL);
	resizeWindow("Contours", 800,800);
	moveWindow("Contours", 500,500);
    imshow( "Contours", drawing );
}

/*
mouse_callback void function that stores 4 mousepositions to set the corners of the chosen farm area
MUST specify points in anti-clockwise order!!
Experimental and not to generate final DEMs
*/

void mouse_callback(int  event, int  x, int  y, int  flag, void *param)
{
    if (event == EVENT_LBUTTONDOWN && cornerCnt < 4) { 
		farmCorners[cornerCnt] = POS{x,y};
		cout << "(" << farmCorners[cornerCnt].x << ", " <<  farmCorners[cornerCnt].y << ")" << endl;
		cornerCnt ++;		
    }
}

/*
createGroveSpace return function returning a 2D integer array to initialize a grid of possible postitions to spawn trees
assign a value of 1 to allow for spawning a tree and 0 to not allow

A tree orchard area is initialized using this function based on any point inside a quadrilateral
Each boundary lines function is computed and a point is deemed inside the quadrilateral if it is
above the lowest line, to the right of the leftmost line, below the topmost line and to the left of the rightmost line
*/
int** createGroveSpace(){
	//initialize max and min values for farm border
	int maxY = 0;
	int maxX = 0;
	int minY = 500000;
	int minX = 500000;  
	for(int i = 0; i < 4 ;i++){
		if(farmCorners[i].x < minX){
			minX = farmCorners[i].x;
		}
		if(farmCorners[i].x > maxX){
			maxX = farmCorners[i].x;
		}

		if(farmCorners[i].y < minY){
			minY = farmCorners[i].y;
		}
		if(farmCorners[i].y > maxY){
			maxY = farmCorners[i].y;
		}
	}
	spawnX = minX;
	spawnY = minY;

	//calculate equation for each line of the farm quadrilateral in terms of x or y
	float m1 = (float)(farmCorners[1].y-farmCorners[0].y)/(float)(farmCorners[1].x-farmCorners[0].x);
	float cX1 = farmCorners[0].x - (farmCorners[0].y/m1);

	float m2 = (float)(farmCorners[2].y-farmCorners[1].y)/(float)(farmCorners[2].x-farmCorners[1].x);
	float cY1 = farmCorners[1].y - (farmCorners[1].x*m2);

	float m3 = (float)(farmCorners[3].y-farmCorners[2].y)/(float)(farmCorners[3].x-farmCorners[2].x);
	float cX2 = farmCorners[2].x - (farmCorners[2].y/m3);

	float m4 = (float)(farmCorners[0].y-farmCorners[3].y)/(float)(farmCorners[0].x-farmCorners[3].x);
	float cY2 = farmCorners[3].y - (farmCorners[3].x*m4);	

	int** farmArea;
	farmWidthY = maxY-minY;
	farmWidthX = maxX-minX;

	farmArea = new int*[farmWidthX]; 
	for (int i = minX; i < maxX ; i++){
		farmArea[i-minX] = new int[farmWidthY];
		for (int j = minY; j < maxY ; j++){
			//check position (i,j) is within the quadrilateral boundary
			if(i > j/m1 + cX1 && i < j/m3 + cX2 &&  j < i*m2 +cY1 && j > i*m4 +cY2){
				farmArea[i - minX][j - minY] = 1;				
			}
			else{
				farmArea[i - minX][j - minY] = 0;
			}		
		}
	}
	return farmArea;
}


/*
addTreesToImage void funtion which draws the actual tree height values to the image
Trees are drawn based on the height of the underlying landscape plus the height of the tree grid value generated in treeGen

different tree drawing functionality for trees drawn on contours and those drawn in grid rows
*/
void addTreesToImage(TreeGroup trees, bool contourDraw){
	//copy the image before changing it to have a reference DEM used for overlapping tree base heights
	Mat imageTemp = copyMat(image, image.cols, image.rows);
	//for each tree in trees spawn a new tree by adding the height values to the landscape
	for(int k = 0 ; k < trees.treeCnt; k++){
		Tree t(treeHeight/2,treeHeight,treeWidth, treeType);
		//random step height to adjust the height of the whole tree slightly to have different sized trees
		float randStep =  rand() % treeHeight/2;
		float stepHeight = 0;
		if (contourDraw){
			stepHeight = imageTemp.at<float>(treeWidth/2 + trees.treePositions[k].y ,treeWidth/2 + trees.treePositions[k].x) + randStep;
		}
		else{
			stepHeight = imageTemp.at<float>(spawnY +treeWidth/2 + trees.treePositions[k].y ,spawnX + treeWidth/2 + trees.treePositions[k].x) + randStep;
		} 
		int dist = t.getWidth();
		for( int x=0; x< dist; x++){
			for( int y=0; y< dist; y++ ){
				if(contourDraw){ //drawing contours
				//base height of the landscape found based on the reference DEM
					float baseHeight = imageTemp.at<float>(y + trees.treePositions[k].y , x + trees.treePositions[k].x);
					//also obtain the height of the changed DEM
					float currentHeight = image.at<float>(y + trees.treePositions[k].y,x + trees.treePositions[k].x);
					//if the original height has changed ie a previous tree is drawn here then average the heights
					if(currentHeight != baseHeight){ 
						//if a tree pixel is not zero ie it is a canopy pixel then add the tree height to the landscape
						if(t.heightGrid[x][y] != 0){
							image.at<float>(y + trees.treePositions[k].y,x + trees.treePositions[k].x) = max((stepHeight + t.heightGrid[x][y]),currentHeight) ; 
						}					
					}
					else{
						if(t.heightGrid[x][y] != 0){
							image.at<float>(y + trees.treePositions[k].y,x + trees.treePositions[k].x) = stepHeight + t.heightGrid[x][y];
						}
					}
				}
				else{
					float baseHeight = imageTemp.at<float>(spawnY + y + trees.treePositions[k].y , spawnX + x + trees.treePositions[k].x);
					float currentHeight = image.at<float>(spawnY + y + trees.treePositions[k].y,spawnX + x + trees.treePositions[k].x);
					//if the original height has changed ie a previous tree is drawn here then average the heights
					if(currentHeight != baseHeight){ 
						if(t.heightGrid[x][y] != 0){ 
							image.at<float>( spawnY + y + trees.treePositions[k].y,spawnX + x + trees.treePositions[k].x) = max((stepHeight + t.heightGrid[x][y]),currentHeight) ; 
						}					
					}
					else{
						if(t.heightGrid[x][y] != 0){
							image.at<float>(spawnY + y + trees.treePositions[k].y,spawnX + x + trees.treePositions[k].x) = stepHeight + t.heightGrid[x][y];
						}
					}
				}					
			}
		}
	}
}
/*
copyMat return function returning a Mat image.
Simply copies another Mat image's values to a new Mat
*/
Mat copyMat(Mat & inputMat, int widthX, int widthY){
	Mat outMat(widthX, widthY, CV_32F); 
	for (int i = 0; i < widthX ; i++){
		for (int j = 0; j < widthY ; j++){
			outMat.at<float>(i,j) = inputMat.at<float>(i,j);
		}
	}
	return outMat;
}
/*
croptTif void function creating a new croppedImage.tif image based on a specified crop size and start pos corner
*/
void croptTif(Mat inputImage, int newWidth, POS startPos){
	Mat outImage(newWidth, newWidth, CV_32F); 
	for(int i = 0 ; i < newWidth; i++){
	 	for(int j = 0 ; j < newWidth ; j++){
			outImage.at<float>(i,j) = inputImage.at<float>(i+startPos.x,j + startPos.y);
		}
	}
	imwrite("output/croppedImage.tif",outImage);
}

/*
printTreeMask void function. Outputs a mask.tif image and a centres.tif image to be used for evaluation later
mask.tif is a black and white image with white pixels drawn for each tree in the final.tif DEM

centres.tif is a black and white image with pixels drawn for the centre of each tree in the final.tif DEM
*/
void printTreeMask(TreeGroup trees, bool contourDraw){
	Mat maskImage (image.cols, image.rows, CV_32F); 
	Mat centreImage (image.cols, image.rows, CV_32F); 
	for( int i=0; i< image.cols; i++){
			for( int j=0; j< image.rows; j++ ){
				maskImage.at<float>(i,j) = 0; 
				centreImage.at<float>(i,j) = 0; 
			}
	}
	for(int k = 0 ; k < trees.treeCnt; k++){
		Tree t(treeHeight/2,treeHeight,treeWidth,treeType);
		int dist = t.getWidth();		
		if(contourDraw){
			centreImage.at<float>(dist/2 + trees.treePositions[k].y,dist/2 + trees.treePositions[k].x) = 255; 
		}
		else{
			centreImage.at<float>(dist/2 + spawnY + trees.treePositions[k].y,dist/2 + spawnX + trees.treePositions[k].x) = 255; 
		}
		for( int x=0; x< dist; x++){
			for( int y=0; y< dist; y++ ){
				if(contourDraw){ 
					if(t.heightGrid[x][y] != 0){
						maskImage.at<float>(y + trees.treePositions[k].y, x + trees.treePositions[k].x) = 255; 						
					}
				}
				else{
					if(t.heightGrid[x][y] != 0){
						maskImage.at<float>(spawnY + y + trees.treePositions[k].y, spawnX + x + trees.treePositions[k].x) = 255 ; 
					}
				}				
			}
		}
	}
	imwrite("output/mask.tif",maskImage);
	imwrite("output/centres.tif",centreImage);
}

